#include <ESP8266WiFi.h>
#include <WiFiUdp.h>
#include <Adafruit_NeoPixel.h>
// ================= 用户配置区 (User Config) =================
// -----------------------------------------------------------
// 【强制重置配网开关】
//  false (no)  = 记忆WiFi (断电后重启自动连) -> 默认
//  true  (yes) = 忘记WiFi (每次上电都强制清除配置，需重新配网)
const bool FORCE_WIFI_RESET = true; 
// -----------------------------------------------------------
// --- 硬件定义 ---
const int PIN_SENSOR = 13;   // 光敏/激光接收管 (低电平触发)
const int PIN_WS2812 = 12;   // WS2812B 数据脚
const int NUM_LEDS   = 3;    // 灯珠数量
const int TCP_PORT   = 8080; // 手机端端口
const int UDP_PORT   = 8266; // 本机UDP端口
Adafruit_NeoPixel strip(NUM_LEDS, PIN_WS2812, NEO_GRB + NEO_KHZ800);
WiFiUDP udp;
WiFiClient client;
IPAddress serverIP;
bool hasFoundServer = false;
bool isTargetActive = false; // 靶子激活状态
unsigned long activeStartTime = 0;
int activeDuration = 3000;   // 默认亮灯时长
void setup() {
  Serial.begin(115200);
  strip.begin();
  strip.setBrightness(50); // 亮度适中
  strip.show(); // 初始全灭
  
  pinMode(PIN_SENSOR, INPUT_PULLUP);
  Serial.println("\n[系统启动 - 高性能优化版]...");
  // ================= 性能优化 1: 关闭 WiFi 休眠 =================
  // 极大降低无线通信延迟，提高命中反馈速度
  WiFi.setSleepMode(WIFI_NONE_SLEEP);
  // ============================================================
  // 1. 强制重置逻辑
  if (FORCE_WIFI_RESET) {
      Serial.println("[配置] 检测到强制重置 -> 清除 WiFi 设置...");
      WiFi.disconnect(true);
      delay(1000);
      setAllLeds(strip.Color(255, 0, 0)); // 红灯长亮提示重置
      delay(500);
      setAllLeds(0);
  }
  // 2. 自动配网逻辑 (如无SSID则进入)
  if (WiFi.SSID() == "") {
      startSmartConfig();
  } else {
      WiFi.mode(WIFI_STA);
      WiFi.begin();
  }
  // 等待连接，超时则重新配网
  int timeout = 0;
  Serial.print("[WiFi] 连接中");
  while (WiFi.status() != WL_CONNECTED) {
    delay(200); // 稍微加快检测频率
    Serial.print(".");
    if (timeout++ > 100) { // 约20秒 (100 * 200ms)
       startSmartConfig();
       break; 
    }
  }
  
  // 连接成功回馈
  if (WiFi.status() == WL_CONNECTED) {
      Serial.println("\n[WiFi] 已连接: " + WiFi.localIP().toString());
      // 蓝灯闪一下表示连接路由器成功
      setAllLeds(strip.Color(0, 0, 255));
      delay(500);
      setAllLeds(0);
  }
  udp.begin(UDP_PORT);
  Serial.println("[UDP] 服务启动");
}
void startSmartConfig() {
  WiFi.disconnect(true);
  delay(1000);
  WiFi.mode(WIFI_STA);
  WiFi.beginSmartConfig();
  Serial.println("\n[SmartConfig] 进入配网模式，请用App发送密码...");
  
  while (!WiFi.smartConfigDone()) {
    static bool s = false; s=!s;
    // 快速闪烁红灯等待
    setAllLeds(s ? strip.Color(255, 0, 0) : 0); 
    delay(150); // 加快闪烁频率
    ESP.wdtFeed();
  }
  
  Serial.println("\n[SmartConfig] 收到配网信息! 连接中...");
  setAllLeds(0);
  
  // 等待最终获取IP
  while (WiFi.status() != WL_CONNECTED) {
      delay(200);
      Serial.print(".");
  }
  Serial.println("\n[WiFi] 配网并连接成功!");
}
// 统一控制颜色
void setAllLeds(uint32_t color) {
  for(int i=0; i<NUM_LEDS; i++) strip.setPixelColor(i, color);
  strip.show();
}
void findServer() {
  // ================= 性能优化 2: 加速 UDP 发现 =================
  // 从 2秒 改为 1秒，更快发现手机
  static unsigned long lastUDP = 0;
  if (millis() - lastUDP > 1000) {
    lastUDP = millis();
    IPAddress broadcastIP = WiFi.broadcastIP(); // 使用获取到的广播地址更稳妥
    udp.beginPacket(broadcastIP, UDP_PORT);
    udp.write("WHO_IS_SERVER"); // App认识的暗号
    udp.endPacket();
    Serial.println("[UDP] 呼叫手机...");
  }
  
  int packetSize = udp.parsePacket();
  if (packetSize) {
    // 收到任何回包即认为是服务器
    serverIP = udp.remoteIP();
    hasFoundServer = true;
    Serial.print("[UDP] 锁定手机IP: "); Serial.println(serverIP);
    
    // 立即闪绿灯一下提示找到服务器
    setAllLeds(strip.Color(0, 100, 0));
    delay(200);
    setAllLeds(0);
  }
}
void connectToApp() {
  Serial.print("[TCP] 连接 App: "); Serial.println(serverIP);
  
  if (client.connect(serverIP, TCP_PORT)) {
    Serial.println("[TCP] 已连接App!");
    
    // ================= 性能优化 3: 禁用 Nagle 算法 =================
    // 确保数据包立即发送，不积压，极大减少击中反馈延迟
    client.setNoDelay(true);
    // ============================================================
    // 发送 V3 握手包
    client.println("ID:" + WiFi.macAddress() + "|STATUS:READY");
    
    // 连接成功特效：绿灯长亮1秒
    setAllLeds(strip.Color(0, 255, 0)); 
    delay(1000);
    setAllLeds(0);
  } else {
    Serial.println("[TCP] 连接失败，重试中...");
    delay(2000); // 缩短重试时间
  }
}
void loop() {
  if (WiFi.status() != WL_CONNECTED) {
      // 掉线重连逻辑可在此处优化，暂保持简单返回
      delay(500);
      return; 
  }
  if (!hasFoundServer) {
    findServer();
  } else if (!client.connected()) {
    setAllLeds(strip.Color(0, 0, 255)); // 掉线蓝灯长亮
    hasFoundServer = false; // 重新走UDP发现流程更稳妥
    connectToApp();
  } else {
    // --- 核心业务逻辑 ---
    processCommands();
    checkHit();
    checkTimeout();
  }
}
void processCommands() {
  while (client.available()) {
    // 读取指令
    String line = client.readStringUntil('\n'); 
    line.trim();
    if (line.length() == 0) continue;
    
    Serial.println("[RX] " + line); // 调试日志
    
    // V3 协议解析: CMD:ON|MAC:xx..|TIME:3000
    if (line.startsWith("CMD:ON")) {
        // 简单提取 TIME
        int timeIdx = line.indexOf("TIME:");
        if (timeIdx > 0) {
            String timeStr = line.substring(timeIdx + 5);
            activeDuration = timeStr.toInt();
        } else {
            activeDuration = 3500; // 默认稍微加长一点容错
        }
        
        // 开启靶子
        isTargetActive = true;
        activeStartTime = millis();
        // 亮灯 (白色，亮度由setup设置)
        setAllLeds(strip.Color(255, 255, 255)); 
        Serial.println("任务开启");
        
    } else if (line.startsWith("CMD:OFF")) {
        // 强制关闭
        isTargetActive = false;
        setAllLeds(0);
        Serial.println("任务关闭");
    }
  }
}
void checkTimeout() {
  if (isTargetActive && (millis() - activeStartTime > (unsigned long)activeDuration)) {
    isTargetActive = false;
    setAllLeds(0);
    Serial.println("超时自动灭");
  }
}
void checkHit() {
  if (isTargetActive) {
    // 检测到低电平（假设激光照射拉低）
    if (digitalRead(PIN_SENSOR) == LOW) {
       Serial.println("[HIT] 击中!");
       
       isTargetActive = false;
       setAllLeds(0); // 立即灭灯反馈
       
       // 回复 App (V3 格式)
       // client.setNoDelay(true) 已开启，此消息会立即发送
       client.print("RESP:HIT|MAC:" + WiFi.macAddress() + "\n");
       
       // 简单的防抖 (从200ms优化到150ms，提升连发手感)
       delay(150); 
    }
  }
}


123